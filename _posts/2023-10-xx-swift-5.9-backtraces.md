---
layout: post
published: true
date: 2023-09-04 10:06:17
title: On-crash Backtraces in Swift
author: [al45tair]
---

Up to now, when a Swift program crashes, we've left it up to the
operating system to deal with the fall out.  On Darwin and Windows
systems, the system-wide crash reporter will kick in and generate a
crash log, but on Linux there typically isn't a system-wide crash
reporter so very likely all you get is a message from the parent
process (often the shell) telling you that the child process crashed.

For instance:

```
$ ./crash
I'm going to crash now
zsh: segmentation fault  ./crash
```

This is clearly less than ideal.

In Swift 5.9, we have added an on-crash backtracing facility directly
to the Swift runtime.  This is enabled by default on Linux and can be
enabled on macOS (see later for instructions).

Instead of the opaque message above, when run from a terminal the
result is something like this:

<pre class="terminal" style='color:#fff; background: #000'>
<span class='shell'>$ </span><span class='cmd'>./crash</span>
I&#39;m going to crash now

💣 <span style='color:#f55'>Program crashed: Bad pointer dereference at 0x0000000000000004</span>

Thread 0 crashed:

<span style='color:#555'>0</span> <span style='color:#5ff'>reallyCrashMe()</span><span style='color:#aaa'> + 404</span> in <span style='color:#a0a'>crash</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crash.swift:4:15</span>

  <span style='color:#555'>   2</span>│   print(&quot;I&#39;m going to crash now&quot;)
  <span style='color:#555'>   3</span>│   let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!
  <span style='background:#1c1c1c'><span style='color:#fff'><span
  style='color:#555'>   4<span style='color: #fff'>│   ptr.pointee = 42</span></span></span>                                                    </span>
  <span style='color:#555'>    </span>│               <span style='color:#f55'>▲</span>
  <span style='color:#555'>   5</span>│ }
  <span style='color:#555'>   6</span>│

<span style='color:#555'>1</span> <span style='color:#5ff'>crashMe()</span><span style='color:#aaa'> + 12</span> in <span style='color:#a0a'>crash</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crash.swift:8:3</span>

  <span style='color:#555'>   6</span>│ 
  <span style='color:#555'>   7</span>│ func crashMe() {
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>   8<span style='color: #fff'>│   reallyCrashMe()</span></span></span>                                                     </span>
  <span style='color:#555'>    </span>│   <span style='color:#f55'>▲</span>
  <span style='color:#555'>   9</span>│ }
  <span style='color:#555'>  10</span>│

<span style='color:#555'>2</span> <span style='color:#5ff'>main</span><span style='color:#aaa'> + 12</span> in <span style='color:#a0a'>crash</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crash.swift:11:1</span>

  <span style='color:#555'>   9</span>│ }
  <span style='color:#555'>  10</span>│ 
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>  11<span style='color: #fff'>│ crashMe()</span></span></span>                                                             </span>
  <span style='color:#555'>    </span>│ <span style='color:#f55'>▲</span>
  <span style='color:#555'>  12</span>│

Press space to interact, D to debug, or any other key to quit (30s)
</pre>

If you run the same program but within a pipeline (so, not attached to
a terminal), you'll instead see a report like this:

```
*** Program crashed: Bad pointer dereference at 0x0000000000000004 ***

Thread 0 crashed:

0               0x00000001045a3df0 reallyCrashMe() + 404 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:4:15
1 [ra]          0x00000001045a3ea4 crashMe() + 12 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:8:3
2 [ra]          0x00000001045a3c50 main + 12 in crash at /Users/alastair/Source/crashDotSwift/crash.swift:11:1
3 [ra] [system] 0x000000018705d058 start + 2224 in dyld


Registers:

 x0 0x0000000000000001  1
 x1 0x0000000000000000  0
 x2 0x0000000000000000  0
 x3 0x000060000016c1c0  c0 c1 28 fd 79 96 00 00 fb 07 00 00 00 00 00 00  ÀÁ(ýy···û·······
 x4 0x000000016b85f098  80 c1 16 00 00 60 00 00 19 00 00 00 00 00 00 00  ·Á···`··········
 x5 0x000000016b85f090  01 00 00 00 00 00 00 00 80 c1 16 00 00 60 00 00  ·········Á···`··
 x6 0x000000000000000a  10
 x7 0x0000000000000000  0
 x8 0x000000000000002a  42
 x9 0x0000000000000004  4
x10 0x0000000000000180  384
x11 0x0000000081a7c008  2175254536
x12 0x00000000000007fb  2043
x13 0x00000000000007fd  2045
x14 0x0000000081c7c807  2177353735
x15 0x0000000000000007  7
x16 0x0000000081a7c008  2175254536
x17 0x000000000007c800  509952
x18 0x0000000000000000  0
x19 0x00000001049bdbd0  68 44 57 e2 01 00 00 00 10 d9 9b 04 01 00 00 00  hDWâ·····Ù······
x20 0x00000001045a3c44  fd 7b bf a9 fd 03 00 91 93 00 00 94 00 00 80 52  ý{¿©ý··········R
x21 0x00000001049bdd38  00 00 00 00 00 00 00 00 20 dd 9b 04 01 00 00 00  ········ Ý······
x22 0x00000001049bd910  00 00 00 00 00 00 00 00 00 00 5a 04 01 00 00 00  ··········Z·····
x23 0x000000016b85f3d0  30 c2 59 e2 01 00 00 00 00 00 00 00 00 00 00 00  0ÂYâ············
x24 0x000000016b85f410  50 f3 85 6b 01 00 00 00 30 80 5b 04 01 00 00 00  Pó·k····0·[·····
x25 0x00000001870dbb1b  2f 75 73 72 2f 6c 69 62 2f 64 79 6c 64 00 5f 5f  /usr/lib/dyld·__
x26 0x0000000000000000  0
x27 0x0000000000000000  0
x28 0x0000000000000000  0
 fp 0x000000016b85f310  20 f3 85 6b 01 00 00 00 a4 3e 5a 04 01 00 00 00   ó·k····¤>Z·····
 lr 0x72268001045a3d44  8225402511295135044
 sp 0x000000016b85f280  a0 f2 85 6b 01 00 00 00 00 00 00 00 00 00 00 00   ò·k············
 pc 0x00000001045a3df0  28 01 00 f9 fd 7b 49 a9 ff 83 02 91 c0 03 5f d6  (··ùý{I©ÿ···À·_Ö


Images (42 omitted):

0x00000001045a0000–0x00000001045a4000 6776aba03ad432b68bc57220ac4e6ef8 crash /Users/alastair/Source/crashDotSwift/crash
0x0000000187057000–0x00000001870ea874 ee3f4181cec538c2b8a84d310be33491 dyld  /usr/lib/dyld
```

### Interactive backtraces

You might be wondering about the message on the last line of the
in-terminal backtrace above, where it says

```
Press space to interact, D to debug, or any other key to quit (30s)
```

Often when developing a program at the terminal, you might find that
the program crashes, but you aren't able to reproduce the problem, and
if you also don't have a suitable crash log, that can be really very
annoying --- you know your program has a bug, but you don't know what
it was or how to reproduce it.

The idea behind this feature is that it leaves the program suspended
(by default for 30 seconds, but this is configurable) and provides you
with the opportunity to either attach a debugger, or to do some
limited additional inspection of the crashed process.

If you tap the spacebar when this prompt appears, you will be
presented with a simple command prompt that allows you to change the
backtracer's settings, generate a new backtrace, list loaded images,
display register and memory contents and get a listing of all of the
threads in the process.  Typing `help` at the prompt will bring up a
list of the available commands:

<pre class="terminal" style="color:#fff; background:#000">
<span style='color:#555'>&gt;&gt;&gt; </span>help
Available commands:

backtrace  Display a backtrace.
bt         Synonym for backtrace.
debug      Attach the debugger.
exit       Exit interaction, allowing program to crash normally.
help       Display help.
images     List images loaded by the program.
mem        Synonym for memory.
memory     Inspect memory.
process    Show information about the process.
quit       Synonym for exit.
reg        Synonym for registers.
registers  Display the registers.
set        Set or show options.
thread     Show or set the current thread.
threads    Synonym for process.
</pre>

If you use the `debug` command or press `D` at the prompt, the
backtracer will help you to attach a debugger to your program.
Exactly what happens here is platform dependent.

If you press any other key, or if the 30 second timer runs down, the
program will be allowed to crash normally.

If for some reason you find the interactive feature triggering in
situations where it shouldn't, for instance if your CI system runs
programs inside a pty instead of a pipe, you can explicitly disable it
by setting the environment variable `SWIFT_BACKTRACE` to
`interactive=no` or (to also disable colored output) `interactive=no,color=no`.

### Swift Concurrency support

The backtracer is concurrency aware and will correctly step back
through asynchronous frames.  For example, given the program

```swift
func level(n: Int) async {
  if n < 5 {
    await level(n: n + 1)
  } else {
    let ptr = UnsafeMutablePointer<Int>(bitPattern: 4)!
    ptr.pointee = 42
  }
}

@main
struct CrashAsync {
  static func main() async {
    await level(n: 1)
  }
}
```

the backtrace will look like

<pre class="terminal" style="color:#fff; background:#000">
<span class='shell'>$ </span><span class='cmd'>./crashAsync</span>

💣 <span style='color:#f55'>Program crashed: Bad pointer dereference at 0x0000000000000004</span>

Thread 1 crashed:

<span style='color:#555'>0</span> <span style='color:#5ff'>level(n:)</span><span style='color:#aaa'> + 308</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:6:17</span>

  <span style='color:#555'>   4</span>│   } else {
  <span style='color:#555'>   5</span>│     let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>   6<span style='color:#fff'>│     ptr.pointee = 42</span></span></span>                                                  </span>
  <span style='color:#555'>    </span>│                 <span style='color:#f55'>▲</span>
  <span style='color:#555'>   7</span>│   }
  <span style='color:#555'>   8</span>│ }

<span style='color:#555'>1</span> <span style='color:#5ff'>level(n:)</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>

  <span style='color:#555'>   1</span>│ func level(n: Int) async {
  <span style='color:#555'>   2</span>│   if n &lt; 5 {
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>   3<span style='color:#fff'>│     await level(n: n + 1)</span></span></span>                                             </span>
  <span style='color:#555'>    </span>│     <span style='color:#f55'>▲</span>
  <span style='color:#555'>   4</span>│   } else {
  <span style='color:#555'>   5</span>│     let ptr = UnsafeMutablePointer&lt;Int&gt;(bitPattern: 4)!

<span style='color:#555'>2</span> <span style='color:#5ff'>level(n:)</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span style='color:#555'>3</span> <span style='color:#5ff'>level(n:)</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span style='color:#555'>4</span> <span style='color:#5ff'>level(n:)</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:3</span>
<span style='color:#555'>5</span> <span style='color:#5ff'>static CrashAsync.main()</span> in <span style='color:#a0a'>crashAsync</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/crashAsync.swift:13</span>

  <span style='color:#555'>  11</span>│ struct CrashAsync {
  <span style='color:#555'>  12</span>│   static func main() async {
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>  13<span style='color:#fff'>│     await level(n: 1)</span></span></span>                                                 </span>
  <span style='color:#555'>    </span>│     <span style='color:#f55'>▲</span>
  <span style='color:#555'>  14</span>│   }
  <span style='color:#555'>  15</span>│ }

Press space to interact, D to debug, or any other key to quit (30s)
</pre>

On non-Darwin platforms, this feature will work as long as symbols are
available.  Without symbols, it isn't possible to determine whether or
not a given frame is asynchronous, and in that case the backtrace will
follow the C stack rather than the async activation chain.

### Other neat features

You can configure the maximum number of frames that the backtracer
will generate (the default is 64), but since you might also want to
see frames at the top of the stack, the backtracer also has a setting
for the number of frames to capture there (by default 16).  This is
particularly handy if your program crashes due to excessive recursion,
as you'll usually see both the recursion and the cause of it, without
being overwhelmed by thousands and thousands of frames.

The backtracer also skips over system frames and Swift thunks by
default.  These are usually not relevant except to compiler or runtime
engineers, and generally result in more confusing output for ordinary
Swift developers.

Additionally, the backtracer will automatically demangle both Swift
and C++ mangled names.

Finally, the backtracer knows about Swift runtime failures; for
example:

<pre class="terminal" style="color:#fff; background:#000">
<span class='shell'>$ </span><span class='cmd'>./overflow</span>

💣 <span style='color:#f55'>Swift runtime failure: arithmetic overflow</span>

Thread 0 crashed:

<span style='color:#555'>0</span> <span style='color:#5ff'>overflow()</span><span style='color:#aaa'> + 324</span> in <span style='color:#a0a'>overflow</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/overflow.swift:4:5</span>

  <span style='color:#555'>   2</span>│ 
  <span style='color:#555'>   3</span>│ func overflow() {
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>   4<span style='color:#fff'>│   x -= 1</span></span></span>                                                              </span>
  <span style='color:#555'>    </span>│     <span style='color:#f55'>▲</span>
  <span style='color:#555'>   5</span>│   print(x)
  <span style='color:#555'>   6</span>│ }

<span style='color:#555'>1</span> <span style='color:#5ff'>main</span><span style='color:#aaa'> + 20</span> in <span style='color:#a0a'>overflow</span> at <span style='color:#a60'>/Users/alastair/Source/crashDotSwift/overflow.swift:8:1</span>

  <span style='color:#555'>   6</span>│ }
  <span style='color:#555'>   7</span>│ 
  <span style='background:#1c1c1c'><span style='color:#fff'><span style='color:#555'>   8<span style='color:#fff'>│ overflow()</span></span></span>                                                            </span>
  <span style='color:#555'>    </span>│ <span style='color:#f55'>▲</span>
  <span style='color:#555'>   9</span>│

Press space to interact, D to debug, or any other key to quit (30s)
</pre>

### Backtracer settings

The backtracer is fairly sophisticated and has a number of settings
that you can use to control its output and operation.  You can find
[documentation for the settings in the Swift
repository](https://github.com/apple/swift/blob/main/docs/Backtracing.rst),
in the docs directory.

### Platform support

There is no support presently on Windows, but it is our intention that
the backtracer will eventually work on the Windows platform.

The backtracer is enabled by default on Linux; if you wish to disable
it for some reason, you can do so by setting the `SWIFT_BACKTRACE`
environment variable to `enable=no`.

The backtracer is also available on macOS, but there it is switched
off by default.  You can enable it by setting `SWIFT_BACKTRACE` to
`enable=yes`, which is sufficient if you build your programs using
Xcode.  If you are using some other build tool to build your program,
you will need to sign the program with the entitlement
`com.apple.security.get-task-allow` in order for the backtracer to
work.  This is the same entitlement you would need to make various
other tools work on your program, so you may already be doing this.
If not, you will need to make a property list file containing the
entitlements you wish to sign your program with, e.g.

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
  "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>com.apple.security.get-task-allow</key>
<true/>
</dict>
</plist>
```

and then to sign your program you should do

```
$ codesign --force --sign - --entitlements entitlements.plist \
    /path/to/your/program
```

Note that programs with the `com.apple.security.get-task-allow`
entitlement will not be accepted for distribution in the App Store,
and will be rejected by notarization.  The entitlement is strictly for
debugging purposes only and software should not be shipped to end
users with it enabled.

The backtracer is not supported on iOS, tvOS or other Darwin
derivatives.

### Out-of-process operation

When a process crashes, it may have corrupted arbitrary memory,
including potentially important runtime data structures, and it may
also be holding or have corrupted various global locks.  Attempting to
generate an in-process backtrace is therefore fraught with danger, and
there is a very real risk that the attempt itself could crash as a
result, obscuring the original problem.

In Swift 5.9, we therefore chose to use an _out-of-process_ design for
our crash handler.  When your program crashes, the runtime will
attempt to launch an executable, `swift-backtrace`, from the `libexec`
directory in your Swift installation.  It is this executable that
generates the backtrace that you see appearing on your terminal, and
that provides the interactive features mentioned above.  When
`swift-backtrace` terminates, the runtime will allow your program to
continue to crash as it would have were the crash not handled at all,
so that any system-wide crash catching mechanism will have a chance to
operate.

This does mean, though, that if you are building a container image,
you will need to ensure that you include a copy of the `libexec`
directory from the Swift installation alongside the `lib` directory
that you would usually have to copy.

### Frame pointers

The current implementation unwinds the stack by following the frame
pointer; if it encounters code that is built without frame pointers,
it will likely stop at that point.  This is mainly an issue on x86 or
x86_64 Linux systems, which often have the compiler flag
`-fomit-frame-pointer` enabled by default.

If you wish to get a more complete backtrace, at a small cost in
performance, you can add the compiler flags `-Xcc
-fno-omit-frame-pointer` when building your Swift program.

### Static linking support

For users who statically link their binaries and do not wish to ship
the Swift runtime library alongside them, there is a statically linked
copy of `swift-backtrace`, named `swift-backtrace-static` , in the
`libexec` directory alongside the normal `swift-backtrace` binary.

By default, to locate `swift-backtrace`, the runtime will attempt to
look in the following locations:

    <swift-root>/libexec/swift/<platform>
    <swift-root>/libexec/swift/<platform>/<arch>
    <swift-root>/libexec/swift
    <swift-root>/libexec/swift/<arch>
    <swift-root>/bin
    <swift-root>/bin/<arch>
    <swift-root>

where `<swift-root>` by default is determined from the path to the
runtime library, `libswiftCore`.

When the runtime is statically linked with _your_ binary, the runtime
will instead determine `<swift-root>` in the above patterns relative
to _your binary_.  For example, if your binary is installed in
e.g. `/usr/bin`, `<swift-root>` would be `/usr`.

You will therefore need to install a copy of `swift-backtrace-static`,
renamed to `swift-backtrace`, in one of the locations above.

You can also explicitly specify the value of `<swift-root>` using the
environment variable `SWIFT_ROOT`, or you can explicitly specify the
location of the backtracer using
`SWIFT_BACKTRACE=swift-backtrace=<path-to-swift-backtrace>`.

If the runtime is unable to locate the backtracer, it will allow your
program to crash as it would have done anyway.
